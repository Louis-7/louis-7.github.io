<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pixel Farm Portfolio</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #2c3e50;
            --modal-bg: #fdf1ce;
            --modal-border: #8b4513;
            --text-color: #4a3b2a;
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: var(--bg-color);
            font-family: 'Press Start 2P', cursive;
            touch-action: none; /* Prevent pull-to-refresh on mobile */
        }

        #gameCanvas {
            display: block;
            image-rendering: pixelated; /* Crucial for the retro look */
            cursor: crosshair;
        }

        /* UI Overlay for Interactions */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        /* --- SETTINGS MENU STYLES --- */
        #settings-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 220px; /* Slightly wider for new tools */
            background-color: rgba(255, 255, 255, 0.95);
            border: 3px solid #000;
            box-shadow: 4px 4px 0px rgba(0,0,0,0.4);
            pointer-events: auto;
            font-family: 'Press Start 2P', cursive;
            display: flex; /* Controlled by JS flag */
            flex-direction: column;
        }

        .panel-header {
            background-color: #2c3e50;
            color: #fff;
            padding: 8px;
            font-size: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
        }

        .panel-body {
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .control-label {
            font-size: 8px;
            color: #555;
            text-transform: uppercase;
        }

        /* Pixel Art Buttons */
        .pixel-btn {
            background: #fff;
            border: 2px solid #4a3b2a;
            padding: 8px;
            font-family: 'Press Start 2P', cursive;
            font-size: 10px;
            color: #4a3b2a;
            cursor: pointer;
            text-align: center;
            box-shadow: 2px 2px 0px #8b4513;
            transition: transform 0.1s, box-shadow 0.1s;
        }

        .pixel-btn:active {
            transform: translate(2px, 2px);
            box-shadow: 0 0 0;
        }

        .pixel-btn.active {
            background-color: #f1c40f;
            border-color: #b78e0c;
        }

        /* Editor Tools Grid */
        #editor-tools {
            display: none; /* Hidden by default */
            grid-template-columns: repeat(5, 1fr); /* Increased columns */
            gap: 5px;
            margin-top: 5px;
        }

        .tool-btn {
            padding: 5px;
            font-size: 14px;
            text-align: center;
            background: #eee;
            border: 2px solid #ccc;
            cursor: pointer;
        }
        .tool-btn.active {
            background: #f1c40f;
            border-color: #000;
        }

        /* Minimize logic */
        #settings-panel.minimized .panel-body {
            display: none;
        }

        /* Interaction Prompt (e.g. "Press Space") */
        #interaction-prompt {
            position: absolute;
            bottom: 20%;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            font-size: 12px;
            display: none;
            animation: bounce 1s infinite;
            pointer-events: none;
            text-align: center;
            white-space: nowrap;
        }

        /* Content Modal */
        #modal-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: none;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            z-index: 100;
        }

        #modal-content {
            width: 80%;
            max-width: 600px;
            max-height: 80%;
            background-color: var(--modal-bg);
            border: 4px solid var(--modal-border);
            box-shadow: 0 0 0 4px #d4a373, 0 10px 20px rgba(0,0,0,0.5);
            border-radius: 4px;
            padding: 20px;
            overflow-y: auto;
            position: relative;
            color: var(--text-color);
            line-height: 1.6;
            font-family: 'Courier New', Courier, monospace; /* Easier to read for long text */
            font-weight: bold;
        }

        #modal-content h2 {
            font-family: 'Press Start 2P', cursive;
            color: #d35400;
            border-bottom: 2px dashed #8b4513;
            padding-bottom: 10px;
            margin-top: 0;
            font-size: 18px;
        }

        #modal-content h3 {
            font-size: 16px;
            color: #8b4513;
            margin-bottom: 5px;
        }

        #modal-content p, #modal-content ul {
            font-size: 14px;
        }

        #close-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #e74c3c;
            border: 2px solid #c0392b;
            color: white;
            width: 30px;
            height: 30px;
            text-align: center;
            line-height: 26px;
            cursor: pointer;
            font-family: 'Press Start 2P', cursive;
        }

        #close-btn:hover {
            background: #c0392b;
        }

        /* Touch Controls */
        #mobile-controls {
            display: none; /* Shown via JS on touch devices */
            position: absolute;
            bottom: 20px;
            width: 100%;
            height: 150px;
            pointer-events: none;
            padding: 0 20px;
            box-sizing: border-box;
        }

        .d-pad {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 120px;
            height: 120px;
            pointer-events: auto;
        }

        .d-btn {
            position: absolute;
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 8px;
        }
        .d-btn:active { background: rgba(255, 255, 255, 0.6); }
        
        .d-up { top: 0; left: 40px; }
        .d-down { bottom: 0; left: 40px; }
        .d-left { top: 40px; left: 0; }
        .d-right { top: 40px; right: 0; }

        .action-btn {
            position: absolute;
            bottom: 40px;
            right: 40px;
            width: 80px;
            height: 80px;
            background: rgba(255, 200, 0, 0.4);
            border: 2px solid rgba(255, 200, 0, 0.6);
            border-radius: 50%;
            pointer-events: auto;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 12px;
            user-select: none;
        }
        .action-btn:active { background: rgba(255, 200, 0, 0.7); }

        @keyframes bounce {
            0%, 100% { transform: translate(-50%, 0); }
            50% { transform: translate(-50%, -5px); }
        }

        /* Scrollbar styling for modal */
        #modal-content::-webkit-scrollbar {
            width: 10px;
        }
        #modal-content::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 4px;
        }
        #modal-content::-webkit-scrollbar-thumb {
            background: #8b4513;
            border-radius: 4px;
        }

    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        
        <!-- NEW SETTINGS MENU (Replaces old Season/Editor UI) -->
        <div id="settings-panel">
            <div class="panel-header" id="panel-header">
                <span>‚öôÔ∏è MENU</span>
                <span id="toggle-icon">‚ñº</span>
            </div>
            <div class="panel-body">
                <!-- Season Control -->
                <div class="control-group">
                    <span class="control-label">Current Season</span>
                    <button class="pixel-btn" id="season-btn">SPRING</button>
                </div>
                
                <!-- Editor Control -->
                <div class="control-group">
                    <span class="control-label">Map Editor</span>
                    <button class="pixel-btn" id="editor-toggle-btn">Enable Editing</button>
                    
                    <div id="editor-tools">
                        <button class="tool-btn active" onclick="setTool('tree')">üå≤</button>
                        <button class="tool-btn" onclick="setTool('rock')">ü™®</button>
                        <button class="tool-btn" onclick="setTool('flower')">üå∏</button>
                        <button class="tool-btn" onclick="setTool('plant')">üåø</button> <!-- New Plant -->
                        <button class="tool-btn" onclick="setTool('cow')">üêÑ</button>   <!-- New Cow -->
                        <button class="tool-btn" onclick="setTool('chicken')">üêî</button><!-- New Chicken -->
                        <button class="tool-btn" onclick="setTool('horse')">üêé</button> <!-- New Horse -->
                        <button class="tool-btn" onclick="setTool('sheep')">üêè</button> <!-- New Sheep -->
                        <button class="tool-btn" onclick="setTool('erase')">‚ùå</button>
                    </div>
                </div>

                <!-- Export -->
                <div class="control-group">
                    <button class="pixel-btn" onclick="exportMap()" style="font-size: 8px;">üíæ Copy Map JSON</button>
                </div>
            </div>
        </div>

        <div id="interaction-prompt">Press SPACE to Interact</div>
        
        <div id="mobile-controls">
            <div class="d-pad">
                <div class="d-btn d-up" id="btn-up"></div>
                <div class="d-btn d-down" id="btn-down"></div>
                <div class="d-btn d-left" id="btn-left"></div>
                <div class="d-btn d-right" id="btn-right"></div>
            </div>
            <div class="action-btn" id="btn-action">A</div>
        </div>
    </div>

    <div id="modal-overlay">
        <div id="modal-content">
            <div id="close-btn">X</div>
            <div id="modal-body"></div>
        </div>
    </div>

    <script>
        /**
         * GLOBAL FLAGS
         */
        const SHOW_SETTINGS_UI = true; // Set to false to hide the menu completely

        /**
         * CONFIGURATION & STATE
         */
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const promptEl = document.getElementById('interaction-prompt');
        const modalOverlay = document.getElementById('modal-overlay');
        const modalBody = document.getElementById('modal-body');
        const closeBtn = document.getElementById('close-btn');

        // Settings Elements
        const settingsPanel = document.getElementById('settings-panel');
        const seasonBtn = document.getElementById('season-btn');
        const editorToggleBtn = document.getElementById('editor-toggle-btn');
        const editorTools = document.getElementById('editor-tools');
        const panelHeader = document.getElementById('panel-header');
        const toggleIcon = document.getElementById('toggle-icon');

        // Game constants
        const TILE_SIZE = 48; // Base unit size
        const PLAYER_SPEED = 4;
        const PLAYER_SIZE = 32;
        const SEASON_DURATION = 60000; // 60 seconds per season
        const SEASONS = ['Spring', 'Summer', 'Fall', 'Winter'];
        
        // World Limits (Playable Area - The Island)
        const WORLD_LIMITS = { minX: -800, maxX: 800, minY: -600, maxY: 600 };

        // Animal Constants
        const ANIMAL_SPEED = 1;
        const ANIMAL_MOVE_CHANCE = 0.02; // Chance to start moving per frame

        const ANIMAL_COLORS = {
            cow: { body: '#e3dac9', spots: '#5d4037', snout: '#f8bbd0' }, // Holstein-ish
            chicken: { body: '#ffffff', comb: '#c0392b', beak: '#f1c40f' }, // White chicken
            horse: { body: '#a1887f', mane: '#5d4037', snout: '#d7ccc8' }, // Brown horse
            sheep: { body: '#ecf0f1', head: '#34495e', legs: '#34495e' } // Fluffy sheep
        };

        const SEASON_PALETTES = {
            'Spring': {
                grass: '#76c758',
                grassDark: '#66b04a',
                dirt: '#8b5e3c',
                wood: '#a05a2c',
                woodDark: '#6d3d1e',
                roof: '#c0392b',
                water: '#3498db',
                treeLight: '#2ecc71',
                treeDark: '#27ae60',
                flowerStem: '#27ae60',
                flowerPetal: '#e74c3c',
                cropLeaf: '#2ecc71',
                cropFruit: ['#e74c3c', '#f1c40f', '#9b59b6']
            },
            'Summer': {
                grass: '#53c738', // Brighter green
                grassDark: '#41a02a',
                dirt: '#8b5e3c',
                wood: '#a05a2c',
                woodDark: '#6d3d1e',
                roof: '#c0392b',
                water: '#3498db',
                treeLight: '#2ecc71',
                treeDark: '#27ae60',
                flowerStem: '#27ae60',
                flowerPetal: '#f39c12',
                cropLeaf: '#27ae60',
                cropFruit: ['#c0392b', '#e67e22', '#f39c12']
            },
            'Fall': {
                grass: '#d68910', // Orange/Brown
                grassDark: '#b9770e',
                dirt: '#6e4c30',
                wood: '#a05a2c',
                woodDark: '#6d3d1e',
                roof: '#922b21',
                water: '#2e86c1',
                treeLight: '#e67e22', // Orange leaves
                treeDark: '#d35400',
                flowerStem: '#8b5e3c', // Drying
                flowerPetal: '#8e44ad',
                cropLeaf: '#d35400',
                cropFruit: ['#e67e22', '#8e44ad', '#c0392b']
            },
            'Winter': {
                grass: '#ecf0f1', // Snow
                grassDark: '#bdc3c7',
                dirt: '#95a5a6',
                wood: '#7f8c8d', // Frozen wood
                woodDark: '#555',
                roof: '#2c3e50',
                water: '#aed6f1', // Icy water
                treeLight: '#dfe6e9', // Snow covered
                treeDark: '#b2babb',
                flowerStem: '#95a5a6',
                flowerPetal: '#3498db',
                cropLeaf: '#bdc3c7',
                cropFruit: ['#ecf0f1', '#95a5a6', '#7f8c8d'] // Frozen
            }
        };

        // Current Colors (will be updated dynamically)
        let COLORS = {...SEASON_PALETTES['Spring']};

        // Game State
        let gameState = {
            player: { x: 0, y: 0, w: PLAYER_SIZE, h: PLAYER_SIZE, dir: 'down', frame: 0, isMoving: false },
            keys: { w: false, a: false, s: false, d: false, ArrowUp: false, ArrowLeft: false, ArrowDown: false, ArrowRight: false, " ": false, Enter: false },
            camera: { x: 0, y: 0 },
            interactionTarget: null,
            isModalOpen: false,
            lastTime: 0,
            season: {
                current: 0, // Index in SEASONS
                timer: 0
            },
            animals: [], // Array to store animal instances
            editor: {
                active: false,
                tool: 'tree',
                mouseX: 0,
                mouseY: 0
            }
        };

        // Content Data (Zones) - Re-organized Layout
        const ZONES = [
            {
                id: 'house',
                x: -80, y: -300, w: 160, h: 140, // Moved up
                type: 'building',
                label: 'My House',
                interactDist: 60,
                collisionBox: { x: 10, y: 40, w: 140, h: 90 },
                door: { x: 70, y: 130 },
                content: `
                    <h2>About Me</h2>
                    <p>Hi! I'm <strong>Alex</strong>, a passionate Full Stack Developer who loves building interactive web experiences.</p>
                    <p>Just like a farmer tends to their crops, I tend to my code‚Äîcultivating clean, efficient, and scalable solutions.</p>
                    <h3>Skills</h3>
                    <ul>
                        <li>JavaScript (React, Node.js)</li>
                        <li>Python (Django, Flask)</li>
                        <li>Database Design (SQL, NoSQL)</li>
                        <li>Pixel Art & Game Dev</li>
                    </ul>
                    <p>Welcome to my little corner of the internet!</p>
                `
            },
            {
                id: 'field1', // Renamed from garden
                x: -350, y: -150, w: 210, h: 210, // Resized to match 30px grid (210/30 = 7)
                type: 'garden',
                label: 'Projects Field',
                interactDist: 80,
                collisionBox: { x: 0, y: 0, w: 210, h: 210 },
                door: { x: 105, y: 220 },
                content: `
                    <h2>Projects Field</h2>
                    <p>Here is what I've been growing lately:</p>
                    
                    <h3>üåæ Crop Analyzer AI</h3>
                    <p>A machine learning model that detects plant diseases from leaf images. Built with TensorFlow and Python.</p>

                    <h3>üöú Auto-Harvester script</h3>
                    <p>An automation tool for optimizing workflows in CI/CD pipelines. Saved my team 10 hours a week!</p>

                    <h3>üêî Co-op Planner</h3>
                    <p>A real-time collaborative task board using WebSockets and React.</p>
                `
            },
            {
                id: 'field2', // New second field
                x: -350, y: 100, w: 210, h: 210, // Resized to match 30px grid (210/30 = 7)
                type: 'garden',
                label: 'Skills Field',
                interactDist: 80,
                collisionBox: { x: 0, y: 0, w: 210, h: 210 },
                door: { x: 105, y: 220 },
                content: `
                    <h2>Skills Field</h2>
                    <p>Cultivating knowledge is key!</p>
                    <ul>
                        <li><strong>Languages:</strong> JavaScript, Python, HTML/CSS, SQL</li>
                        <li><strong>Frameworks:</strong> React, Node.js, Django, Flask</li>
                        <li><strong>Tools:</strong> Git, Docker, Webpack</li>
                        <li><strong>Design:</strong> Figma, Aseprite (for pixel art!)</li>
                    </ul>
                `
            },
            {
                id: 'board',
                x: 120, y: -100, w: 80, h: 60, // Moved near house
                type: 'sign',
                label: 'Blog Board',
                interactDist: 50,
                collisionBox: { x: 10, y: 10, w: 60, h: 50 },
                door: { x: 40, y: 65 },
                content: `
                    <h2>Community Board (Blog)</h2>
                    
                    <h3>üìÖ Oct 20, 2023: Moving to VIM</h3>
                    <p>Why I abandoned my mouse and how it changed my workflow forever.</p>

                    <h3>üìÖ Sep 15, 2023: Canvas API 101</h3>
                    <p>A tutorial on how to build exactly what you are looking at right now!</p>

                    <h3>üìÖ Aug 01, 2023: burnout.js</h3>
                    <p>Managing mental health in a fast-paced tech environment.</p>
                `
            },
            {
                id: 'mailbox',
                x: 60, y: -140, w: 30, h: 50, // Moved right next to house door
                type: 'mailbox',
                label: 'Resume/Contact',
                interactDist: 40,
                collisionBox: { x: 0, y: 0, w: 30, h: 50 },
                door: { x: 15, y: 55 },
                content: `
                    <h2>Resume & Contact</h2>
                    <p><strong>Email:</strong> alex@pixelvalley.dev</p>
                    <p><strong>GitHub:</strong> github.com/alexdev</p>
                    <hr>
                    <h3>Experience</h3>
                    <p><strong>Senior Dev @ Joja Corp</strong> (2020 - Present)<br>Leading frontend migration to React.</p>
                    <p><strong>Freelance Developer</strong> (2018 - 2020)<br>Built e-commerce sites for local businesses.</p>
                    <h3>Education</h3>
                    <p>B.S. Computer Science, State University</p>
                `
            }
        ];

        // Data Arrays
        let SCENERY = [];
        let ANIMALS = [];
        let BOUNDARY_OBJECTS = [];
        
        // Helper to create an animal
        function createAnimal(type, x, y) {
            ANIMALS.push({
                x: x, y: y,
                type: type,
                dir: 'down',
                frame: 0,
                isMoving: false,
                moveTimer: 0
            });
        }

        // Initialize the new map layout
        function initScenery() {
            SCENERY = [];
            ANIMALS = [];
            BOUNDARY_OBJECTS = [];

            // 1. Place boundaries (Fences)
            // REMOVED OUTER FENCES PER REQUEST (User: "I don't want fence around my island")
            
            // Pasture Fence (Right side of the map)
            const pastureRect = { x: 150, y: -200, w: 400, h: 500 };
            const spacing = 40;
            for(let x = pastureRect.x; x <= pastureRect.x + pastureRect.w; x += spacing) {
                if(x > pastureRect.x + 100 && x < pastureRect.x + 180 && y === pastureRect.y + pastureRect.h) continue; // Leave a gate
                BOUNDARY_OBJECTS.push({x: x, y: pastureRect.y, type: 'fence'});
                BOUNDARY_OBJECTS.push({x: x, y: pastureRect.y + pastureRect.h, type: 'fence'});
            }
            for(let y = pastureRect.y; y <= pastureRect.y + pastureRect.h; y += spacing) {
                BOUNDARY_OBJECTS.push({x: pastureRect.x, y: y, type: 'fence'});
                BOUNDARY_OBJECTS.push({x: pastureRect.x + pastureRect.w, y: y, type: 'fence'});
            }

            // 2. Place Initial Animals in Pasture
            createAnimal('cow', 250, 0);
            createAnimal('cow', 400, 100);
            createAnimal('chicken', 200, -100);
            createAnimal('chicken', 220, -80);
            createAnimal('chicken', 180, -120);
            createAnimal('horse', 350, -50);
            createAnimal('sheep', 300, 150);
            createAnimal('sheep', 450, 200);

            // 3. Place Scenery (Trees, rocks)
            // Fill outer areas
            for(let i=0; i<100; i++) {
                const x = Math.random() * (WORLD_LIMITS.maxX - WORLD_LIMITS.minX) + WORLD_LIMITS.minX;
                const y = Math.random() * (WORLD_LIMITS.maxY - WORLD_LIMITS.minY) + WORLD_LIMITS.minY;
                
                // Avoid placing inside the main farm area (simple rectangular check)
                if(x > -400 && x < 600 && y > -350 && y < 400) continue;

                SCENERY.push({
                    x: x,
                    y: y,
                    type: Math.random() > 0.7 ? 'rock' : 'tree'
                });
            }
            // Place some specific nice-looking ones
            SCENERY.push({x: -150, y: -250, type: 'tree'}); // Near house
            SCENERY.push({x: 80, y: -250, type: 'tree'});  // Near house
            SCENERY.push({x: -400, y: -200, type: 'rock'}); // Near top field
        }

        /**
         * SEASON LOGIC
         */
        function nextSeason() {
            gameState.season.current = (gameState.season.current + 1) % SEASONS.length;
            gameState.season.timer = 0; // Reset timer for full duration
            applySeason();
        }

        function applySeason() {
            const newSeason = SEASONS[gameState.season.current];
            COLORS = {...SEASON_PALETTES[newSeason]};
            if(seasonBtn) seasonBtn.innerText = newSeason; // Update button text
            console.log("Season changed to " + newSeason);
        }

        if(seasonBtn) seasonBtn.addEventListener('click', nextSeason);


        /**
         * SETTINGS & EDITOR LOGIC
         */

        // Initial Visibility Check
        if (!SHOW_SETTINGS_UI) {
            settingsPanel.style.display = 'none';
        }

        // Toggle Panel Minimize
        panelHeader.addEventListener('click', () => {
            settingsPanel.classList.toggle('minimized');
            toggleIcon.innerText = settingsPanel.classList.contains('minimized') ? '‚ñ∂' : '‚ñº';
        });

        // Toggle Edit Mode
        editorToggleBtn.addEventListener('click', () => {
            gameState.editor.active = !gameState.editor.active;
            
            if(gameState.editor.active) {
                editorToggleBtn.innerText = "Disable Editing";
                editorToggleBtn.classList.add('active');
                editorTools.style.display = 'grid';
            } else {
                editorToggleBtn.innerText = "Enable Editing";
                editorToggleBtn.classList.remove('active');
                editorTools.style.display = 'none';
            }
        });

        window.setTool = function(tool) {
            gameState.editor.tool = tool;
            // Update UI
            document.querySelectorAll('#editor-tools .tool-btn').forEach(btn => {
                // Crude check for active class based on onclick attr
                if(btn.outerHTML.includes(tool)) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
        };

        window.exportMap = function() {
            // Export both Scenery and Animals
            const data = JSON.stringify({ scenery: SCENERY, animals: ANIMALS });
            // Copy to clipboard
            navigator.clipboard.writeText(data).then(() => {
                alert('Map data copied to clipboard! You can save this JSON.');
            });
            console.log(data);
        };

        // Mouse listeners for editor
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            gameState.editor.mouseX = e.clientX - rect.left;
            gameState.editor.mouseY = e.clientY - rect.top;
        });

        canvas.addEventListener('mousedown', (e) => {
            if (!gameState.editor.active) return;
            
            const rect = canvas.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const clickY = e.clientY - rect.top;
            
            const worldX = Math.round(clickX + gameState.camera.x);
            const worldY = Math.round(clickY + gameState.camera.y);
            const clickThreshold = 30;

            if (gameState.editor.tool === 'erase') {
                // Find closest object in SCENERY
                let idx = SCENERY.findIndex(s => Math.hypot(s.x - worldX, s.y - worldY) < clickThreshold);
                if (idx !== -1) {
                    SCENERY.splice(idx, 1);
                } else {
                    // If not found, check ANIMALS
                    idx = ANIMALS.findIndex(a => Math.hypot(a.x - worldX, a.y - worldY) < clickThreshold);
                    if (idx !== -1) {
                        ANIMALS.splice(idx, 1);
                    }
                }
            } else if (['cow', 'chicken', 'horse', 'sheep'].includes(gameState.editor.tool)) {
                // Add animal
                createAnimal(gameState.editor.tool, worldX, worldY);
            } else {
                // Add scenery (tree, rock, flower, plant)
                SCENERY.push({
                    x: worldX,
                    y: worldY,
                    type: gameState.editor.tool
                });
            }
        });


        /**
         * INPUT HANDLING
         */
        window.addEventListener('keydown', (e) => {
            if(gameState.keys.hasOwnProperty(e.key) || e.key === "ArrowUp" || e.key === "ArrowDown" || e.key === "ArrowLeft" || e.key === "ArrowRight") {
                gameState.keys[e.key] = true;
            }
            
            // Interaction triggers
            if((e.key === ' ' || e.key === 'Enter') && !gameState.isModalOpen && gameState.interactionTarget) {
                openModal(gameState.interactionTarget.content);
            }
        });

        window.addEventListener('keyup', (e) => {
            if(gameState.keys.hasOwnProperty(e.key) || e.key === "ArrowUp" || e.key === "ArrowDown" || e.key === "ArrowLeft" || e.key === "ArrowRight") {
                gameState.keys[e.key] = false;
            }
        });

        // Touch Controls
        const btnUp = document.getElementById('btn-up');
        const btnDown = document.getElementById('btn-down');
        const btnLeft = document.getElementById('btn-left');
        const btnRight = document.getElementById('btn-right');
        const btnAction = document.getElementById('btn-action');
        const mobileControls = document.getElementById('mobile-controls');

        // Detect touch device roughly
        if('ontouchstart' in window || navigator.maxTouchPoints > 0) {
            mobileControls.style.display = 'block';
            promptEl.innerText = "Tap 'A' to Interact";
        }

        const addTouch = (elem, key) => {
            elem.addEventListener('touchstart', (e) => { e.preventDefault(); gameState.keys[key] = true; });
            elem.addEventListener('touchend', (e) => { e.preventDefault(); gameState.keys[key] = false; });
        };

        addTouch(btnUp, 'ArrowUp');
        addTouch(btnDown, 'ArrowDown');
        addTouch(btnLeft, 'ArrowLeft');
        addTouch(btnRight, 'ArrowRight');
        
        btnAction.addEventListener('touchstart', (e) => {
            e.preventDefault(); 
            if(!gameState.isModalOpen && gameState.interactionTarget) {
                openModal(gameState.interactionTarget.content);
            }
        });

        /**
         * GAME LOGIC
         */
        function init() {
            resize();
            window.addEventListener('resize', resize);
            
            initScenery();

            // Start player in front of the new house location
            gameState.player.x = 0;
            gameState.player.y = -150;

            requestAnimationFrame(loop);
        }

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            ctx.imageSmoothingEnabled = false; // Keep pixel art crisp
        }

        function update(deltaTime) {
            if (gameState.isModalOpen) return;

            // -- SEASON LOGIC --
            gameState.season.timer += deltaTime;
            if (gameState.season.timer >= SEASON_DURATION) {
                nextSeason();
            }

            // -- ANIMAL LOGIC --
            ANIMALS.forEach(animal => {
                if (animal.isMoving) {
                    animal.moveTimer -= deltaTime;
                    if (animal.moveTimer <= 0) {
                        animal.isMoving = false;
                        animal.frame = 0;
                    } else {
                        // Move
                        let dx = 0, dy = 0;
                        if (animal.dir === 'up') dy = -ANIMAL_SPEED;
                        if (animal.dir === 'down') dy = ANIMAL_SPEED;
                        if (animal.dir === 'left') dx = -ANIMAL_SPEED;
                        if (animal.dir === 'right') dx = ANIMAL_SPEED;

                        let newX = animal.x + dx;
                        let newY = animal.y + dy;

                        // Simple boundary check (keep them roughly in the world)
                        // A real system would check against fences specifically
                        if (newX < WORLD_LIMITS.minX + 20 || newX > WORLD_LIMITS.maxX - 20) newX = animal.x;
                        if (newY < WORLD_LIMITS.minY + 20 || newY > WORLD_LIMITS.maxY - 20) newY = animal.y;
                        
                        animal.x = newX;
                        animal.y = newY;
                        
                        // Animate
                        animal.frame = (animal.frame + deltaTime * 0.01) % 2; // Simple 2-frame animation
                    }
                } else {
                    // Randomly start moving
                    if (Math.random() < ANIMAL_MOVE_CHANCE) {
                        animal.isMoving = true;
                        animal.moveTimer = 1000 + Math.random() * 2000; // Move for 1-3 seconds
                        const dirs = ['up', 'down', 'left', 'right'];
                        animal.dir = dirs[Math.floor(Math.random() * dirs.length)];
                    }
                }
            });
            // ------------------

            const p = gameState.player;
            let dx = 0;
            let dy = 0;

            if (gameState.keys.w || gameState.keys.ArrowUp) dy = -PLAYER_SPEED;
            if (gameState.keys.s || gameState.keys.ArrowDown) dy = PLAYER_SPEED;
            if (gameState.keys.a || gameState.keys.ArrowLeft) dx = -PLAYER_SPEED;
            if (gameState.keys.d || gameState.keys.ArrowRight) dx = PLAYER_SPEED;

            // Normalize diagonal movement
            if (dx !== 0 && dy !== 0) {
                dx *= 0.707;
                dy *= 0.707;
            }

            if (dx !== 0 || dy !== 0) {
                p.isMoving = true;
                
                // Determine direction
                if (Math.abs(dx) > Math.abs(dy)) {
                    p.dir = dx > 0 ? 'right' : 'left';
                } else {
                    p.dir = dy > 0 ? 'down' : 'up';
                }

                // Check collision with objects
                let newX = p.x + dx;
                let newY = p.y + dy;

                // World Boundary Constraints (The Island)
                // Stop if player tries to walk off the island rect
                if (newX < WORLD_LIMITS.minX) newX = p.x;
                if (newX > WORLD_LIMITS.maxX - p.w) newX = p.x;
                if (newY < WORLD_LIMITS.minY) newY = p.y;
                if (newY > WORLD_LIMITS.maxY - p.h) newY = p.y;

                if (!checkCollision(newX, p.y)) p.x = newX;
                if (!checkCollision(p.x, newY)) p.y = newY;

            } else {
                p.isMoving = false;
            }

            // Check interaction
            checkInteraction();

            // Update Camera
            gameState.camera.x = p.x - canvas.width / 2 + p.w / 2;
            gameState.camera.y = p.y - canvas.height / 2 + p.h / 2;
        }

        function checkCollision(x, y) {
            const pBox = { x: x, y: y + PLAYER_SIZE/2, w: PLAYER_SIZE, h: PLAYER_SIZE/2 }; // Collision at feet

            for (let zone of ZONES) {
                const box = zone.collisionBox;
                const zoneX = zone.x + box.x;
                const zoneY = zone.y + box.y;
                
                if (pBox.x < zoneX + box.w &&
                    pBox.x + pBox.w > zoneX &&
                    pBox.y < zoneY + box.h &&
                    pBox.y + pBox.h > zoneY) {
                    return true;
                }
            }
            return false;
        }

        function checkInteraction() {
            const p = gameState.player;
            const pCenter = { x: p.x + p.w/2, y: p.y + p.h/2 };
            
            let closest = null;
            let minDst = Infinity;

            for (let zone of ZONES) {
                const door = { x: zone.x + zone.door.x, y: zone.y + zone.door.y };
                const dist = Math.hypot(pCenter.x - door.x, pCenter.y - door.y);

                if (dist < zone.interactDist && dist < minDst) {
                    minDst = dist;
                    closest = zone;
                }
            }

            gameState.interactionTarget = closest;
            
            if (closest) {
                promptEl.style.display = 'block';
            } else {
                promptEl.style.display = 'none';
            }
        }

        function openModal(content) {
            gameState.isModalOpen = true;
            modalBody.innerHTML = content;
            modalOverlay.style.display = 'flex';
            // Reset keys so player doesn't keep walking
            Object.keys(gameState.keys).forEach(k => gameState.keys[k] = false);
        }

        function closeModal() {
            gameState.isModalOpen = false;
            modalOverlay.style.display = 'none';
        }

        closeBtn.addEventListener('click', closeModal);
        modalOverlay.addEventListener('click', (e) => {
            if (e.target === modalOverlay) closeModal();
        });

        /**
         * RENDERING
         */
        function draw() {
            // Clear Screen
            ctx.fillStyle = '#111';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.save();
            // Apply Camera
            ctx.translate(-gameState.camera.x, -gameState.camera.y);

            // Draw Ground
            drawGround();

            // Sort entities by Y for depth sorting (pseudo-3D)
            const entities = [
                ...SCENERY.map(s => ({...s, drawType: 'scenery', z: s.y})),
                ...BOUNDARY_OBJECTS.map(b => ({...b, drawType: 'fence', z: b.y + 10})),
                ...ZONES.map(z => ({...z, drawType: 'zone', z: z.y + z.collisionBox.h + z.collisionBox.y})),
                ...ANIMALS.map(a => ({...a, drawType: 'animal', z: a.y + 2})), // Add animals
                { drawType: 'player', z: gameState.player.y + gameState.player.h }
            ];

            entities.sort((a, b) => a.z - b.z);

            entities.forEach(e => {
                if(e.drawType === 'scenery') drawScenery(e);
                if(e.drawType === 'fence') drawFence(e);
                if(e.drawType === 'zone') drawZone(e);
                if(e.drawType === 'animal') drawAnimal(e);
                if(e.drawType === 'player') drawPlayer();
            });

            // Draw Interaction Marker
            if(gameState.interactionTarget) {
                const t = gameState.interactionTarget;
                const x = t.x + t.door.x;
                const y = t.y + t.door.y - 30;
                
                ctx.fillStyle = 'white';
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 2;
                
                // Bobbing arrow
                const offset = Math.sin(Date.now() / 200) * 5;
                
                ctx.beginPath();
                ctx.moveTo(x - 10, y + offset);
                ctx.lineTo(x + 10, y + offset);
                ctx.lineTo(x, y + 10 + offset);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
            }

            // Draw Editor Ghost
            if(gameState.editor.active && gameState.editor.tool !== 'erase') {
                const worldX = gameState.editor.mouseX + gameState.camera.x;
                const worldY = gameState.editor.mouseY + gameState.camera.y;
                
                ctx.globalAlpha = 0.5; // Ghost effect
                
                if (['cow', 'chicken', 'horse', 'sheep'].includes(gameState.editor.tool)) {
                    drawAnimal({x: worldX, y: worldY, type: gameState.editor.tool, isMoving: false, frame: 0});
                } else {
                    drawScenery({x: worldX, y: worldY, type: gameState.editor.tool});
                }
                
                ctx.globalAlpha = 1.0;
                
                // Cursor circle
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(worldX, worldY, 20, 0, Math.PI*2);
                ctx.stroke();
            } else if (gameState.editor.active && gameState.editor.tool === 'erase') {
                const worldX = gameState.editor.mouseX + gameState.camera.x;
                const worldY = gameState.editor.mouseY + gameState.camera.y;
                ctx.strokeStyle = 'red';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(worldX, worldY, 15, 0, Math.PI*2);
                ctx.moveTo(worldX - 10, worldY - 10);
                ctx.lineTo(worldX + 10, worldY + 10);
                ctx.moveTo(worldX + 10, worldY - 10);
                ctx.lineTo(worldX - 10, worldY + 10);
                ctx.stroke();
            }

            ctx.restore();
        }

        function drawGround() {
            // 1. Draw Water (Screen wide, based on camera view)
            ctx.fillStyle = COLORS.water;
            ctx.fillRect(gameState.camera.x, gameState.camera.y, canvas.width, canvas.height);

            // 2. Water Animation (Simple sparkles/waves)
            const time = Date.now();
            ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
            
            // Draw random-ish waves based on world coordinates visible in camera
            const startX = Math.floor(gameState.camera.x / 50) * 50;
            const startY = Math.floor(gameState.camera.y / 50) * 50;
            const w = canvas.width + 100;
            const h = canvas.height + 100;
            
            for(let x = startX; x < startX + w; x += 50) {
                for(let y = startY; y < startY + h; y += 50) {
                    // Create deterministic "randomness" for position offset
                    const offsetX = Math.sin(x * 99 + time / 1000) * 20;
                    const offsetY = Math.cos(y * 88 + time / 1000) * 20;
                    
                    // Only draw if outside the island rect
                    if (x + offsetX < WORLD_LIMITS.minX || x + offsetX > WORLD_LIMITS.maxX || 
                        y + offsetY < WORLD_LIMITS.minY || y + offsetY > WORLD_LIMITS.maxY) {
                         
                        // Draw wave foam
                        const size = (Math.sin(time / 500 + x) + 1) * 2 + 1;
                        ctx.fillRect(x + offsetX, y + offsetY, size * 2, size);
                    }
                }
            }

            // 3. Draw The Island (Grass)
            ctx.fillStyle = COLORS.grass;
            ctx.fillRect(WORLD_LIMITS.minX, WORLD_LIMITS.minY, WORLD_LIMITS.maxX - WORLD_LIMITS.minX, WORLD_LIMITS.maxY - WORLD_LIMITS.minY);

            // 4. Grass Texture (Inside Island)
            ctx.fillStyle = COLORS.grassDark;
            for(let x = WORLD_LIMITS.minX; x < WORLD_LIMITS.maxX; x+=50) {
                for(let y = WORLD_LIMITS.minY; y < WORLD_LIMITS.maxY; y+=50) {
                    if ((Math.abs(x * y) % 7) === 0) {
                        ctx.fillRect(x + 10, y + 10, 5, 5);
                        ctx.fillRect(x + 15, y + 5, 5, 5);
                    }
                }
            }
        }

        function drawFence(obj) {
             // Simple post
             ctx.fillStyle = COLORS.woodDark;
             ctx.fillRect(obj.x, obj.y - 15, 8, 20);
             // Horizontal rails
             ctx.fillStyle = COLORS.wood;
             ctx.fillRect(obj.x - 10, obj.y - 10, 42, 4); // Connects to next post
             ctx.fillRect(obj.x - 10, obj.y - 2, 42, 4);
        }

        function drawScenery(obj) {
            if(obj.type === 'tree') {
                // Trunk
                ctx.fillStyle = COLORS.woodDark;
                ctx.fillRect(obj.x - 8, obj.y - 10, 16, 30);
                // Leaves
                ctx.fillStyle = COLORS.treeLight; // Dynamic color
                ctx.beginPath();
                ctx.arc(obj.x, obj.y - 30, 25, 0, Math.PI*2);
                ctx.fill();
                ctx.fillStyle = COLORS.treeDark; // Dynamic color
                ctx.beginPath();
                ctx.arc(obj.x - 10, obj.y - 35, 15, 0, Math.PI*2);
                ctx.fill();
            } else if (obj.type === 'rock') {
                ctx.fillStyle = '#7f8c8d';
                ctx.beginPath();
                ctx.arc(obj.x, obj.y, 10, 0, Math.PI*2);
                ctx.fill();
                ctx.fillStyle = '#95a5a6';
                ctx.fillRect(obj.x-5, obj.y-8, 5, 5);
            } else if (obj.type === 'flower') {
                ctx.fillStyle = COLORS.flowerStem; // Dynamic
                ctx.fillRect(obj.x - 1, obj.y, 2, 8);
                ctx.fillStyle = COLORS.flowerPetal; // Dynamic
                ctx.beginPath();
                ctx.arc(obj.x, obj.y, 4, 0, Math.PI*2);
                ctx.fill();
                ctx.fillStyle = '#f1c40f'; // Center
                ctx.beginPath();
                ctx.arc(obj.x, obj.y, 1.5, 0, Math.PI*2);
                ctx.fill();
            } else if (obj.type === 'plant') {
                // Simple generic crop/plant
                ctx.fillStyle = COLORS.cropLeaf;
                ctx.beginPath();
                ctx.arc(obj.x, obj.y - 4, 6, 0, Math.PI*2);
                ctx.fill();
                ctx.fillStyle = COLORS.cropFruit[0]; // Just use first fruit color
                ctx.beginPath();
                ctx.arc(obj.x, obj.y - 8, 3, 0, Math.PI*2);
                ctx.fill();
            }
        }

        function drawAnimal(animal) {
            const x = animal.x;
            const y = animal.y;
            const colors = ANIMAL_COLORS[animal.type];
            const frameOffset = animal.isMoving && Math.floor(animal.frame) === 1 ? 2 : 0;

            ctx.save();
            
            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.2)';
            ctx.beginPath();
            ctx.ellipse(x, y + 4, 10, 5, 0, 0, Math.PI*2);
            ctx.fill();

            if (animal.type === 'cow') {
                ctx.fillStyle = colors.body;
                ctx.fillRect(x - 14, y - 20, 28, 20); // Body
                ctx.fillStyle = colors.spots;
                ctx.fillRect(x - 10, y - 18, 8, 10); // Spot
                ctx.fillRect(x + 4, y - 15, 6, 8); // Spot
                ctx.fillStyle = colors.body;
                ctx.fillRect(x - 16, y - 24, 14, 14); // Head
                ctx.fillStyle = colors.snout;
                ctx.fillRect(x - 16, y - 14, 14, 4); // Snout
                // Legs
                ctx.fillStyle = colors.body;
                ctx.fillRect(x - 12, y, 6, 6 + frameOffset);
                ctx.fillRect(x + 6, y, 6, 6 - frameOffset);

            } else if (animal.type === 'chicken') {
                ctx.fillStyle = colors.body;
                ctx.fillRect(x - 6, y - 10, 12, 10); // Body
                ctx.fillStyle = colors.comb;
                ctx.fillRect(x - 2, y - 12, 4, 2); // Comb
                ctx.fillStyle = colors.beak;
                ctx.fillRect(x + 4, y - 8, 2, 2); // Beak
                // Legs
                ctx.fillStyle = '#e67e22';
                ctx.fillRect(x - 4, y, 2, 4 + frameOffset);
                ctx.fillRect(x + 2, y, 2, 4 - frameOffset);
                
            } else if (animal.type === 'horse') {
                ctx.fillStyle = colors.body;
                ctx.fillRect(x - 14, y - 22, 28, 18); // Body
                ctx.fillStyle = colors.mane;
                ctx.fillRect(x - 16, y - 28, 6, 14); // Mane/Neck
                ctx.fillStyle = colors.body;
                ctx.fillRect(x - 18, y - 28, 10, 12); // Head
                ctx.fillStyle = colors.snout;
                ctx.fillRect(x - 18, y - 18, 6, 4); // Snout
                 // Legs
                ctx.fillStyle = colors.body;
                ctx.fillRect(x - 12, y - 4, 6, 8 + frameOffset);
                ctx.fillRect(x + 6, y - 4, 6, 8 - frameOffset);

            } else if (animal.type === 'sheep') {
                ctx.fillStyle = colors.body;
                 // Woolly Body (using circles for fluffiness)
                ctx.beginPath(); ctx.arc(x - 5, y - 10, 8, 0, Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.arc(x + 5, y - 10, 8, 0, Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.arc(x, y - 14, 8, 0, Math.PI*2); ctx.fill();
                
                ctx.fillStyle = colors.head;
                ctx.fillRect(x - 14, y - 18, 10, 10); // Head
                // Legs
                ctx.fillStyle = colors.legs;
                ctx.fillRect(x - 10, y - 4, 4, 8 + frameOffset);
                ctx.fillRect(x + 6, y - 4, 4, 8 - frameOffset);
            }

            ctx.restore();
        }

        function drawZone(zone) {
            if (zone.type === 'building') {
                // Shadow
                ctx.fillStyle = 'rgba(0,0,0,0.2)';
                ctx.fillRect(zone.x + 10, zone.y + 100, 140, 40);

                // Walls
                ctx.fillStyle = '#f5d76e'; // Yellowish wall
                ctx.fillRect(zone.x + 10, zone.y + 40, 140, 90);
                
                // Wood trim
                ctx.fillStyle = COLORS.wood;
                ctx.fillRect(zone.x + 10, zone.y + 40, 140, 10); // Top trim
                ctx.fillRect(zone.x + 10, zone.y + 120, 140, 10); // Bottom trim
                ctx.fillRect(zone.x + 10, zone.y + 40, 10, 90); // Left
                ctx.fillRect(zone.x + 140, zone.y + 40, 10, 90); // Right

                // Roof
                ctx.fillStyle = COLORS.roof;
                ctx.beginPath();
                ctx.moveTo(zone.x - 10, zone.y + 40);
                ctx.lineTo(zone.x + 80, zone.y - 20);
                ctx.lineTo(zone.x + 170, zone.y + 40);
                ctx.fill();

                // Door
                ctx.fillStyle = COLORS.woodDark;
                ctx.fillRect(zone.x + 60, zone.y + 80, 40, 50);
                ctx.fillStyle = '#f39c12'; // Knob
                ctx.fillRect(zone.x + 90, zone.y + 105, 4, 4);

                // Window
                ctx.fillStyle = '#85c1e9';
                ctx.fillRect(zone.x + 25, zone.y + 60, 30, 30);
                ctx.fillStyle = COLORS.wood;
                ctx.fillRect(zone.x + 38, zone.y + 60, 4, 30);
                ctx.fillRect(zone.x + 25, zone.y + 73, 30, 4);

            } else if (zone.type === 'garden') {
                // Soil
                ctx.fillStyle = COLORS.dirt;
                ctx.fillRect(zone.x, zone.y, zone.w, zone.h);
                
                // Grid lines
                ctx.strokeStyle = 'rgba(0,0,0,0.1)';
                ctx.beginPath();
                for(let gx=0; gx<=zone.w; gx+=30) {
                    ctx.moveTo(zone.x + gx, zone.y);
                    ctx.lineTo(zone.x + gx, zone.y + zone.h);
                }
                for(let gy=0; gy<=zone.h; gy+=30) {
                    ctx.moveTo(zone.x, zone.y + gy);
                    ctx.lineTo(zone.x + zone.w, zone.y + gy);
                }
                ctx.stroke();

                // Crops
                for(let gx=15; gx<zone.w; gx+=30) {
                    for(let gy=15; gy<zone.h; gy+=30) {
                        // Plant
                        ctx.fillStyle = COLORS.cropLeaf; // DYNAMIC COLOR
                        ctx.beginPath();
                        ctx.arc(zone.x + gx, zone.y + gy, 10, 0, Math.PI*2);
                        ctx.fill();
                        
                        // Fruit/Flower (random color from palette)
                        const palette = COLORS.cropFruit;
                        const color = palette[(gx+gy)%palette.length];
                        
                        ctx.fillStyle = color;
                        ctx.beginPath();
                        ctx.arc(zone.x + gx, zone.y + gy - 5, 4, 0, Math.PI*2);
                        ctx.fill();
                    }
                }
                
                // Sign
                ctx.fillStyle = COLORS.wood;
                ctx.fillRect(zone.x + zone.w/2 - 2, zone.y - 20, 4, 20);
                ctx.fillStyle = COLORS.woodDark;
                ctx.fillRect(zone.x + zone.w/2 - 15, zone.y - 35, 30, 20);

            } else if (zone.type === 'sign') {
                // Legs
                ctx.fillStyle = COLORS.wood;
                ctx.fillRect(zone.x + 15, zone.y + 30, 5, 20);
                ctx.fillRect(zone.x + 40, zone.y + 30, 5, 20);
                // Board
                ctx.fillStyle = COLORS.woodDark;
                ctx.fillRect(zone.x, zone.y, zone.w, 40);
                // Paper
                ctx.fillStyle = '#fff';
                ctx.fillRect(zone.x + 5, zone.y + 5, zone.w - 10, 30);
                // Lines
                ctx.fillStyle = '#333';
                ctx.fillRect(zone.x + 10, zone.y + 15, zone.w - 20, 2);
                ctx.fillRect(zone.x + 10, zone.y + 25, zone.w - 20, 2);

            } else if (zone.type === 'mailbox') {
                ctx.fillStyle = '#bdc3c7'; // Post
                ctx.fillRect(zone.x + 12, zone.y + 20, 6, 30);
                ctx.fillStyle = '#34495e'; // Box
                ctx.beginPath();
                ctx.arc(zone.x + 15, zone.y + 10, 15, Math.PI, 0);
                ctx.lineTo(zone.x + 30, zone.y + 20);
                ctx.lineTo(zone.x, zone.y + 20);
                ctx.fill();
                ctx.fillStyle = '#c0392b'; // Flag
                ctx.fillRect(zone.x + 28, zone.y + 5, 2, 10);
                ctx.fillRect(zone.x + 28, zone.y + 5, 8, 5);
            }
        }

        function drawPlayer() {
            const p = gameState.player;
            const x = p.x;
            const y = p.y;
            
            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.beginPath();
            ctx.ellipse(x + 16, y + 30, 10, 4, 0, 0, Math.PI*2);
            ctx.fill();

            // Simple Character Drawing
            
            // Legs (animated)
            ctx.fillStyle = '#2c3e50'; // Pants
            if (p.isMoving) {
                const step = Math.sin(Date.now() / 100) * 5;
                ctx.fillRect(x + 8, y + 20 + step, 6, 12); // Left leg
                ctx.fillRect(x + 18, y + 20 - step, 6, 12); // Right leg
            } else {
                ctx.fillRect(x + 8, y + 20, 6, 12);
                ctx.fillRect(x + 18, y + 20, 6, 12);
            }

            // Body (Shirt)
            ctx.fillStyle = '#e74c3c'; // Red shirt
            ctx.fillRect(x + 6, y + 12, 20, 14);

            // Head
            ctx.fillStyle = '#f1c40f'; // Skin
            ctx.fillRect(x + 8, y, 16, 14);

            // Hat
            ctx.fillStyle = '#2980b9'; // Blue hat
            ctx.fillRect(x + 6, y - 4, 20, 6); // Brim
            ctx.fillRect(x + 8, y - 8, 16, 6); // Top

            // Face details based on direction
            ctx.fillStyle = 'black';
            if (p.dir === 'down') {
                ctx.fillRect(x + 12, y + 6, 2, 2); // Eye
                ctx.fillRect(x + 18, y + 6, 2, 2); // Eye
            } else if (p.dir === 'right') {
                ctx.fillRect(x + 18, y + 6, 2, 2); // Eye
            } else if (p.dir === 'left') {
                ctx.fillRect(x + 12, y + 6, 2, 2); // Eye
            }
            
            // Label "Me"
            ctx.fillStyle = 'white';
            ctx.font = '10px "Press Start 2P"';
            ctx.fillText('Me', x + 6, y - 15);
        }

        function loop(timestamp) {
            const deltaTime = timestamp - gameState.lastTime;
            gameState.lastTime = timestamp;
            update(deltaTime);
            draw();
            requestAnimationFrame(loop);
        }

        // Start
        init();

    </script>
</body>
</html>